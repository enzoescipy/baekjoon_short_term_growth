> [!keyword]
> - [[DP]], [[knapsack]]
> - [[다이나믹 프로그래밍]]
> - [[0/1 배낭 문제]]
> - [[공간 최적화]]

# 지시문 및 문제 설명
## 문제
https://www.acmicpc.net/problem/12865

이 문제는 아주 평범한 배낭에 관한 문제이다.

한 달 후면 국가의 부름을 받게 되는 준서는 여행을 가려고 한다. 세상과의 단절을 슬퍼하며 최대한 즐기기 위한 여행이기 때문에, 가지고 다닐 배낭 또한 최대한 가치 있게 싸려고 한다.

준서가 여행에 필요하다고 생각하는 N개의 물건이 있다. 각 물건은 무게 W와 가치 V를 가지는데, 해당 물건을 배낭에 넣어서 가면 준서가 V만큼 즐길 수 있다. 아직 행군을 해본 적이 없는 준서는 최대 K만큼의 무게만을 넣을 수 있는 배낭만 들고 다닐 수 있다. 준서가 최대한 즐거운 여행을 하기 위해 배낭에 넣을 수 있는 물건들의 가치의 최댓값을 알려주자.

## 입력
첫 줄에 물품의 수 N(1 ≤ N ≤ 100)과 준서가 버틸 수 있는 무게 K(1 ≤ K ≤ 100,000)가 주어진다. 두 번째 줄부터 N개의 줄에 거쳐 각 물건의 무게 W(1 ≤ W ≤ 100,000)와 해당 물건의 가치 V(0 ≤ V ≤ 1,000)가 주어진다.

입력으로 주어지는 모든 수는 정수이다.

## 출력
한 줄에 배낭에 넣을 수 있는 물건들의 가치합의 최댓값을 출력한다.

## 예제 입력 1
```
4 7
6 13
4 8
3 6
5 12
```

## 예제 출력 1
```
14
```

# 접근 및 해설

## 나의 접근 진화 과정
> [!note] 코딩 여정 요약
> 초기에는 [[DFS]], [[BFS]] 접근을 시도했지만 실패. 이후 여러 [[DP]] 접근법으로 진화하면서 최종적으로 [[공간 최적화]]된 솔루션을 개발했다.

### 1. 초기 접근법 - [[백트래킹]]
- 모든 아이템을 포함하고 하나씩 제거하는 방식으로 시도
- 비효율적인 가지치기와 백트래킹 사용
- 문제점: 지수 [[시간 복잡도]], 역방향 접근(아이템 제거)

### 2. [[DP]] 구현
- DP 구현을 위한 여러 헬퍼 함수와 데이터 구조 사용
- 튜플 리스트와 선형 검색 활용
- 디버깅을 위한 상세 아이템 추적 유지
- 진전: 알고리즘은 맞지만 비효율적인 구현

### 3. 선형 인덱싱 및 [[HashMap]] 최적화
- 다양한 인덱싱 전략 시도
- [[HashMap]]으로 선형 검색 대체
- 문제점: [[HashMap]] 접근법은 오버헤드로 인한 메모리 제한 초과

### 4. [[공간 최적화]] 솔루션
- 최종 작동 솔루션은 공간 효율적인 접근법 사용
- 전체 DP 테이블 대신 두 개의 배열만 유지
- **성공**: [[시간 복잡도]]와 [[공간 복잡도]] 모두 통과

## 문제 분석
> [!note] 핵심 포인트
> 1. 각 물건은 하나씩만 선택 가능 ([[0/1 knapsack]])
> 2. 무게 제한이 있음 (K)
> 3. 가치의 최댓값을 구해야 함
> 4. 모든 입력값은 정수

## 해결 방법 (최종 접근법)
### [[공간 최적화]] [[DP]] 접근법
1. **두 개의 1D 배열 사용**:
   - `dp_old`: 이전 상태 저장
   - `dp_new`: 현재 계산 중인 상태 저장
   - 각 반복 후 배열 업데이트

2. **점화식 (동일)**:
```
dp[i][w] = max(
    dp[i-1][w],                    # i번째 물건을 선택하지 않는 경우
    dp[i-1][w-weights[i]] + values[i]  # i번째 물건을 선택하는 경우
)
```

3. **[[공간 최적화]]의 핵심**:
   - DP 테이블에서 현재 행은 이전 행에만 의존
   - 따라서 전체 2D 배열 대신 두 개의 1D 배열만 필요
   - 계산 후 배열을 교체하여 공간 사용 최소화

### [[공간 복잡도]] 분석
- 기존 2D 방식: O(N×K) 공간
- 최적화된 2-배열 방식: O(2×K) = O(K) 공간
- K ≤ 100,000 일 때 메모리 사용량 크게 감소

### 코드 구현 핵심 부분
```python
def main_double_1d_array(candidate, limit):
    candidate.insert(0,(0,0))
    limit = limit + 1
    
    dp_old = [0 for i in range(limit)]
    dp_new = [0 for i in range(limit)]
    dp = [dp_old, dp_new]
    
    # ... 코드 생략 ...
    
    for k in range(candidate_len):
        for i in range(limit):
            # ... DP 로직 ...
            if additive_case > continue_case:
                res = additive_case
            else:
                res = continue_case
            
            knapsack_set(i, res)
        knapsack_push()  # 배열 교체
```

## [[HashMap]] vs [[배열]] 접근법
### [[HashMap]] 접근법 (메모리 초과)
- 장점: 희소 상태만 저장하여 이론적으로 공간 절약 가능
- 단점: 각 키-값 쌍의 오버헤드가 크고 대부분의 상태를 저장해야 함

### [[배열]] 접근법 (성공)
- 장점: 일관된 접근 시간, 낮은 오버헤드
- 특히 이중 1D 배열 방식은 공간을 O(K)로 최적화

## 교훈
1. **[[DP]] [[공간 최적화]]**: 2D DP 테이블을 1D로 최적화할 수 있는 경우가 많음
2. **[[데이터 구조]] 트레이드오프**: [[HashMap]]이 항상 더 나은 것은 아님
3. **가설 검증**: 이론적 최적화가 실제 환경에서는 다르게 작동할 수 있음
4. **알고리즘 진화**: 단계적으로 개선하며 최적의 솔루션 도출

## 핵심 인사이트
1. 일반적인 [[DP]] 접근의 [[공간 복잡도]]는 O(N×K)
2. [[DP]] 상태 전이가 이전 행에만 의존할 때 공간을 O(K)로 최적화 가능
3. [[HashMap]]의 오버헤드는 크기 때문에 밀집된 상태에서는 [[배열]]이 더 효율적
4. 실제 메모리 제약이 있는 문제에서는 [[공간 최적화]]가 필수적

## 출처
- 문제를 만든 사람: [Acka](https://www.acmicpc.net/user/Acka)
- 데이터를 추가한 사람: [kpqi5858](https://www.acmicpc.net/user/kpqi5858), [leedongbin](https://www.acmicpc.net/user/leedongbin), [riroan](https://www.acmicpc.net/user/riroan), [skyoliver](https://www.acmicpc.net/user/skyoliver)

## 관련 문제
- [[11049]] 행렬 곱셈 순서 ([[DP]])
- [[9251]] LCS ([[DP]])
- [[2293]] 동전 1 ([[DP]])

